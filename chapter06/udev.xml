<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-udev" role="wrap">
  <?dbhtml filename="udev.html"?>

  <title>Udev-&udev-version;</title>

  <indexterm zone="ch-system-udev">
    <primary sortas="a-Udev">Udev</primary>
  </indexterm>

  <sect2 role="package">
    <title/>

    <para>The Udev package contains programs for dynamic creation of device
    nodes.</para>

    <segmentedlist>
      <segtitle>&buildtime;</segtitle>
      <segtitle>&diskspace;</segtitle>

      <seglistitem>
        <seg>0.1 SBU</seg>
        <seg>3.8 MB</seg>
      </seglistitem>
    </segmentedlist>

    <segmentedlist>
      <segtitle>&dependencies;</segtitle>

      <seglistitem>
        <seg>Coreutils, GCC, Make, and Perl</seg>
      </seglistitem>
    </segmentedlist>

  </sect2>

  <sect2 role="installation">
    <title>Installation of Udev</title>

    <para>Compile the package:</para>

<screen><userinput>make EXTRAS=extras/run_directory</userinput></screen>

    <variablelist>
      <title>The meaning of the make option:</title>

      <varlistentry>
        <term><parameter>EXTRAS=extras/run_directory</parameter></term>
        <listitem>
          <para>This builds the <command>udev_run_devd</command> and
          <command>udev_run_hotplugd</command> binaries, which are required
          for correct handling of hotpluggable devices.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>To test the results, issue:
    <userinput>make test</userinput>.</para>

    <para>Install the package:</para>

<screen><userinput>make DESTDIR=/ EXTRAS=extras/run_directory install</userinput></screen>

    <variablelist>
      <title>The meaning of the make parameter:</title>

      <varlistentry>
        <term><parameter>DESTDIR=/</parameter></term>
        <listitem>
          <para>This prevents the Udev build process from killing any
          <command>udevd</command> processes that may be running on the
          host system.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Udev's configuration is far from ideal by default, so install
    the configuration files here:</para>

<screen><userinput>cp -v ../&udev-config-file; /etc/udev/rules.d/25-lfs.rules</userinput></screen>

    <para>Install the documentation that explains how to create Udev rules:</para>

<screen><userinput>install -m644 -D -v docs/writing_udev_rules/index.html /usr/share/doc/udev-&udev-version;/index.html</userinput></screen>

    <!-- Not for the LiveCD -->
    <!-- Edit Me -->
    <para>Run the <command>udevstart</command> program to create our full
    complement of device nodes.</para>

<screen><userinput>/sbin/udevstart</userinput></screen>

  </sect2>

  <sect2 id="contents-udev" role="content">
    <title>Contents of Udev</title>

    <segmentedlist>
      <segtitle>Installed programs</segtitle>
      <segtitle>Installed directory</segtitle>

      <seglistitem>
        <seg>udev, udev_run_devd, udev_run_hotplugd, udevcontrol, udevd,
        udevinfo, udevmonitor, udevsend, udevstart, and udevtest</seg>
        <seg>/etc/udev</seg>
      </seglistitem>
    </segmentedlist>

    <variablelist>
      <bridgehead renderas="sect3">Short Descriptions</bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>

      <varlistentry id="udev">
        <term><command>udev</command></term>
        <listitem>
          <para>Creates device nodes in <filename class="directory">/dev</filename>
          or renames network interfaces (not in LFS) in response to hotplug
          events</para>
          <indexterm zone="ch-system-udev udev">
            <primary sortas="b-udev">udev</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udev_run_devd">
        <term><command>udev_run_devd</command></term>
        <listitem>
          <para>Executes programs and scripts in the <filename
          class="directory">/etc/dev.d/</filename> directory in response to
          hotplug events</para>
          <indexterm zone="ch-system-udev udev_run_devd">
            <primary sortas="b-udev_run_devd">udev_run_devd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udev_run_hotplugd">
        <term><command>udev_run_hotplugd</command></term>
        <listitem>
          <para>Executes programs and scripts in the <filename
          class="directory">/etc/hotplug.d/</filename> directory in response
          to hotplug events</para>
          <indexterm zone="ch-system-udev udev_run_hotplugd">
            <primary sortas="b-udev_run_hotplugd">udev_run_hotplugd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevcontrol">
        <term><command>udevcontrol</command></term>
        <listitem>
          <para>Configures a number of options for the running
          <command>udevd</command> daemon, such as the log level.</para>
          <indexterm zone="ch-system-udev udevcontrol">
            <primary sortas="b-udevcontrol">udevcontrol</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevd">
        <term><command>udevd</command></term>
        <listitem>
          <para>A daemon that reorders hotplug events before submitting them to
          <command>udev</command>, thus avoiding various race conditions</para>
          <indexterm zone="ch-system-udev udevd">
            <primary sortas="b-udevd">udevd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevinfo">
        <term><command>udevinfo</command></term>
        <listitem>
          <para>Allows users to query the <command>udev</command> database for
          information on any device currently present on the system; it also
          provides a way to query any device in the <systemitem
          class="filesystem">sysfs</systemitem> tree to help create udev
          rules</para>
          <indexterm zone="ch-system-udev udevinfo">
            <primary sortas="b-udevinfo">udevinfo</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevmonitor">
        <term><command>udevmonitor</command></term>
        <listitem>
          <para>Prints the event received from the kernel and the event which
          <command>udev</command> sends out after rule processing</para>
          <indexterm zone="ch-system-udev udevmonitor">
            <primary sortas="b-udevmonitor">udevmonitor</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevsend">
        <term><command>udevsend</command></term>
        <listitem>
          <para>Delivers hotplug events to <command>udevd</command></para>
          <indexterm zone="ch-system-udev udevsend">
            <primary sortas="b-udevsend">udevsend</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevstart">
        <term><command>udevstart</command></term>
        <listitem>
          <para>Creates device nodes in <filename class="directory">/dev</filename>
          that correspond to drivers compiled directly into the kernel; it
          performs that task by simulating hotplug events presumably dropped by
          the kernel before invocation of this program (e.g., because the root
          filesystem has not been mounted) and submitting such synthetic hotplug
          events to <command>udev</command></para>
          <indexterm zone="ch-system-udev udevstart">
            <primary sortas="b-udevstart">udevstart</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevtest">
        <term><command>udevtest</command></term>
        <listitem>
          <para>Simulates a <command>udev</command> run for the given device,
          and prints out the name of the node the real <command>udev</command>
          would have created or (not in LFS) the name of the renamed network
          interface</para>
          <indexterm zone="ch-system-udev udevtest">
            <primary sortas="b-udevtest">udevtest</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="etc-udev">
        <term><filename class="directory">/etc/udev</filename></term>
        <listitem>
          <para>Contains <command>udev</command> configuation files,
          device permissions, and rules for device naming</para>
          <indexterm zone="ch-system-udev etc-udev">
            <primary sortas="e-/etc/udev">/etc/udev</primary>
          </indexterm>
        </listitem>
      </varlistentry>

    </variablelist>

  </sect2>

</sect1>
